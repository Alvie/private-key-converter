<!DOCTYPE html>
<html lang="en">

	<head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title>Document</title>
		<style>
			* {
				font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
			}
			.monotype {
				font-family: 'Courier New', Courier, monospace;
				font-size: 1rem;
				font-weight: bold;
			}
			#private-key-input {
				width: 36em;
				display: block;
				font-size: 1rem;
			}
		</style>
	</head>
	<body>
		<h1>Private Key Converter</h1>
		<h2>Private Key Input</h2>
		<span>Input your old private key (may start with 7): </span>
		<input id="private-key-input" class="monotype" type="text" spellcheck="false" autocomplete="off"></input>
		<h2>Private Key Output:</h2>
		<span id="message"></span>
		<section>
			<span>Uncompressed: </span><span id="private-key-output" class="monotype"></span>
		</section>
		<section>
			<span>Compressed: </span><span id="private-key-output-compressed" class="monotype"></span>
		</section>
		<script>
			'use strict';
			// ENCODING RELATED FUNCTIONS
			const ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';

			function bigIntPow(bigInt, index) {
				let pow = 1n;
				while (index) {
					if (index & 1) pow *= bigInt;
					index = index >> 1;
					bigInt *= bigInt;
				}
				return pow;
			}

			function wifToDecimal(privateKey) {
				let decimalPrivateKey = 0n;
				const reversedPrivateKeyArray = privateKey.split('').reverse();

				for (let i = 0; i < reversedPrivateKeyArray.length; i++) {
					let multiplier = bigIntPow(58n, i);
					let index = ALPHABET.indexOf(reversedPrivateKeyArray[i]);
					decimalPrivateKey += BigInt(index) * multiplier;
				}
				return decimalPrivateKey;
			}

			function decimalToHex(decimalPrivateKey) {
				// Convert to hex and remove, prefix and checksum
				// (   prefix:   first byte = first 2 chars )
				// ( checksum: last 4 bytes = last 8 chars  )
				return decimalPrivateKey.toString(16).slice(2, -8);
			}

			function hexToDecimal(hexPrivateKey) {
				return BigInt('0x' + hexPrivateKey);
			}

			function stringToBuffer(string) {
				var buffer = new Uint8Array(
					string.match(/[\da-f]{2}/gi).map(function (h) {
						return parseInt(h, 16);
					})
				);
				return buffer;
			}

			function bufferToHex(buffer) {
				var hexCodes = [];
				var view = new DataView(buffer);
				for (var i = 0; i < view.byteLength; i += 4) {
					// Using getUint32 reduces the number of iterations needed (we process 4 bytes each time)
					// toString(16) will give the hex representation of the number without padding
					var stringValue = view.getUint32(i).toString(16);
					var paddedValue = ('00000000' + stringValue).slice(-8);
					hexCodes.push(paddedValue);
				}
				return hexCodes.join('');
			}

			async function sha256(hexString) {
				// We transform the string into an arraybuffer.
				var buffer = stringToBuffer(hexString);
				const hash = await crypto.subtle.digest('SHA-256', buffer);
				return bufferToHex(hash);
			}

			async function getDigestFromKey(hexPrivateKey) {
				const hashedHexPrivateKey = await sha256(hexPrivateKey);
				const digest = await sha256(hashedHexPrivateKey);

				return digest;
			}

			function decimalToWif(decimalPrivateKey) {
				let wifString = '';
				while (decimalPrivateKey > 0n) {
					let r = decimalPrivateKey % 58n;
					wifString = wifString + ALPHABET[Number(r)];
					decimalPrivateKey = decimalPrivateKey / 58n;
				}
				return wifString.split('').reverse().join('');
			}

			async function convertToNew(privateKey) {
				const decimalPrivateKey = wifToDecimal(privateKey);
				const hexPrivateKey = decimalToHex(decimalPrivateKey);
				const prefixedHexPrivateKey = '80' + hexPrivateKey;
				const compressedPrefixedHexPrivateKey = '80' + hexPrivateKey + '01';

				const digest = await getDigestFromKey(prefixedHexPrivateKey);
				const checksum = digest.slice(0, 8);
				const converted = hexToDecimal(prefixedHexPrivateKey + checksum);
				const convertedPrivateKey = decimalToWif(converted);

				const compressedDigest = await getDigestFromKey(compressedPrefixedHexPrivateKey);
				const compressedChecksum = compressedDigest.slice(0, 8);
				const compressedConverted = hexToDecimal(compressedPrefixedHexPrivateKey + compressedChecksum);
				const compressedConvertedPrivateKey = decimalToWif(compressedConverted);

				if (convertedPrivateKey[0] !== '5' || !['K', 'L'].includes(compressedConvertedPrivateKey[0])) {
					throw TypeError('Inputted private key is not valid')
				}

				return [convertedPrivateKey, compressedConvertedPrivateKey];
			}

			// PAGE RELATED FUNCTIONS

			async function showNewPrivateKeys() {
				const input = document.querySelector('#private-key-input');
				const message = document.querySelector('#message');
				const output = document.querySelector('#private-key-output');
				const outputCompressed = document.querySelector('#private-key-output-compressed');

				try {
					let convertedPrivateKeyArray = await convertToNew(input.value.trim());
					message.textContent = 'Success';
					output.textContent = convertedPrivateKeyArray[0];
					outputCompressed.textContent = convertedPrivateKeyArray[1];
				} catch (error) {
					output.textContent = '';
					outputCompressed.textContent = '';
					message.textContent = (error.message);
				}
			}

			function pageLoaded() {
				const input = document.querySelector('#private-key-input')
				input.addEventListener('change', showNewPrivateKeys)
				input.addEventListener('keyup', showNewPrivateKeys)
			}

			window.addEventListener('load', pageLoaded);
		</script>
	</body>
</html>